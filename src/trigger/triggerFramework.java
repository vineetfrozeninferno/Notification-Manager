package trigger;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;

import event.eventFramework;

/*
 * The framework will hold all the TAUs and call them at the appropriate minute in the hour.
 * The framework will call the TAU and get the triggers generated and send it to the eventFramework.
 * The eventFramework has to deal with the trigger data afterwards.
 */

public class triggerFramework implements Runnable
{	
	//list of the TAUs and the triggerMinute at which they are to be executed to get the triggers
	static EnumMap<triggerMinutes, List<triggerAcquisitionUnit>> triggerMap = new EnumMap<triggerMinutes, List<triggerAcquisitionUnit>>(triggerMinutes.class);
	static Thread trigFrameworkThread = null;
	public static boolean killThread=false;
	/*
	 * register a TAU with the triggerFramework.
	 */
	public static void registerTriggerAcquisitionUnit(triggerAcquisitionUnit tau)
	{
		if(triggerMap.containsKey(tau.wakeMeUpEveryThMinuteOfTheHour()) == false || triggerMap.get(tau.wakeMeUpEveryThMinuteOfTheHour()).isEmpty())
		{	//no trigger has registered itself for this interval
			List<triggerAcquisitionUnit> tmp = new ArrayList<triggerAcquisitionUnit>();
			tmp.add(tau);
			triggerMap.put(tau.wakeMeUpEveryThMinuteOfTheHour(), tmp);
		}
		else
		{	//triggers have been registered for this interval
			for(triggerAcquisitionUnit t : triggerMap.get(tau.wakeMeUpEveryThMinuteOfTheHour()))
			{
				if(tau.equals(t))
					return;
			}
			
			//a TAU with this name does not exist
			List<triggerAcquisitionUnit> tmp = triggerMap.get(tau.wakeMeUpEveryThMinuteOfTheHour());
			tmp.add(tau);
			triggerMap.put(tau.wakeMeUpEveryThMinuteOfTheHour(), tmp);
		}
	}
	
	//change this function to work with android platforms
	private long getEpochTimeInSeconds()
	{
		long epochSec = System.currentTimeMillis()/1000;
		return epochSec;
	}
	
	/*
	 * The eventFramework thread is started from here.
	 * It is an infinite looping function.
	 * It runs the appropriate TAU and the given minute and after getting the triggers from those TAUs
	 * it sends them to the eventFramework. It then goes to sleep till the next minute.
	 */
	public void startThread()
	{
		List<triggerType> triggersGenerated = new ArrayList<triggerType>();
		
		while(killThread == false)
		{
			//clear the list of triggers generated in the last minute
			triggersGenerated.clear();
			long currentMin = getEpochTimeInSeconds()/60;
			
			//check if the triggerInterval has been reached and run the TAU 
			for(triggerMinutes trigInt : triggerMap.keySet())
			{
				if(currentMin % trigInt.getValue() == 0)	//if the time interval has expired
				{//get all the triggers generated by the TAUs for that triggerInterval
					for(triggerAcquisitionUnit tau : triggerMap.get(trigInt))
					{
						triggersGenerated.addAll(tau.acquireTrigger());
					}
				}
			}
			
			//send the triggers to the event framework
			eventFramework.addTriggersToQueue(triggersGenerated);
			
			//sleep till next minute - This is to ensure that it wakes up at the beginning of the next minute
			long nxtMinute = (getEpochTimeInSeconds()/60) + 1;
			long sleepTime = (nxtMinute * 60) - getEpochTimeInSeconds(); 
			try {
				Thread.sleep(sleepTime * 1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			};
			
		}//end of while loop
		
		//free the thread
		trigFrameworkThread = null;
	}

	@Override
	public void run()
	{
		startThread();
	}
	
	public static void startFramework()
	{
		killThread = false;
		//create new thread and start it if the thread has not been created
		if(trigFrameworkThread == null)
		{
			trigFrameworkThread = new Thread(new triggerFramework());
			
			//start the trig thread..
			trigFrameworkThread.start();
		}
	}
	
}